#include "noaftodo_config.h"

#include <curses.h>
#include <fstream>
#include <vector>

#include "noaftodo.h"
#include "noaftodo_cui.h"
#include "noaftodo_output.h"

using namespace std;

string conf_filename = "noaftodo.conf";

map <string, string> conf_cvars;

void conf_load()
{
	conf_load(conf_filename);
}

void conf_load(const string& conf_file)
{
	log("Loading config from " + conf_file + "...");

	ifstream iconf(conf_file);
	if (!iconf.good())
	{	// create a new config from a template
		log("Config file does not exist!", LP_ERROR);
		log("Creating a new one from template...");

		ofstream oconf(conf_file);
		// there must be a smarter way to do this
		oconf << "# config file generated by NOAFtodo 1.0.1\n\n"
			"bind q \"q\" 1 true\n"
			"bind \"esc\" \"q\" 1 true\n"
			"bind : \":\" 1 true\n"
			"bind \"up\" \"up\" 1 true\n"
			"bind k \"up\" 1 true\n"
			"bind \"down\" \"down\" 1 true\n"
			"bind j \"down\" 1 true\n"
			"bind a \"a a\" 1 false\n"
			"bind A \"a\" 1 false\n"
			"bind \" \" \"c\" 1 true\n"
			"bind d \"d\" 1 false\n"
			"bind ? \"?\" 1 true\n"
			"bind F \"vtoggle failed\" 1 true\n"
			"bind U \"vtoggle uncat\" 1 true\n"
			"bind C \"vtoggle coming\" 1 true\n"
			"bind V \"vtoggle complete\" 1 true\n";
	}

	iconf = ifstream(conf_file);
	if (!iconf.good())
	{
		log("Something went wrong!", LP_ERROR);
		return;
	}

	string entry;

	while (getline(iconf, entry))
	{
		if (entry != "")
		{
			while (entry.at(0) == ' ') 
			{ 
				entry = entry.substr(1);
				if (entry == "") break;
			}

			if (entry != "") if (entry.at(0) != '#')
			{
				log(entry);

				vector<string> tokens;
				string temp = "";
				bool inquotes = false;
				bool skip_special = false;
				for (int i = 0; i < entry.length(); i++)
				{
					const char c = entry.at(i);
					if (skip_special) 
					{
						temp += c;
						skip_special = false;
					} else switch (c) {
						case '\\':
							skip_special = true;
							break;
						case '"':
							inquotes = !inquotes;
							break;
						case ' ':
							if (!inquotes)
							{
								if (temp != "")
								{
									tokens.push_back(temp);
									temp = "";
								}
							} else temp += c;
							break;
						default:
							temp += c;
							break;
					}
				}

				tokens.push_back(temp);

				if (tokens.size() != 0) // do we really need these precautions?
				{
					if (tokens.at(0) == "bind")
					{
						if (tokens.size() == 5)
						{
							const string skey = tokens.at(1);
							const string scomm = tokens.at(2);
							const int smode = stoi(tokens.at(3));
							const bool sauto = (tokens.at(4) == "true");

							log("Binding " + skey + " to '" + scomm + "'");
							if (skey.length() == 1)
								cui_bind(skey.at(0), scomm, smode, sauto);
							else
							{
								if (skey == "up")
									cui_bind(KEY_UP, scomm, smode, sauto);
								if (skey == "down")
									cui_bind(KEY_DOWN, scomm, smode, sauto);
								if (skey == "left")
									cui_bind(KEY_LEFT, scomm, smode, sauto);
								if (skey == "right")
									cui_bind(KEY_RIGHT, scomm, smode, sauto);
								if (skey == "esc")
									cui_bind(27, scomm, smode, sauto);
							}
						} else log("Incorrect number of arguments for config entry 'bind'", LP_ERROR);
					}
					if (tokens.at(0) == "charset")
					{
						if (tokens.size() == 3)
						{
							if (tokens.at(1) == "status_separator")
							{
								cui_charset.status_separator = tokens.at(2).at(0);
							}
							if (tokens.at(1) == "row_separator")
							{
								cui_charset.row_separator = tokens.at(2).at(0);
							}
						}
					}
					if (tokens.at(0) == "set")
					{
						if (tokens.size() == 3)
						{
							conf_set_cvar(tokens.at(1), tokens.at(2));
						}
					}
				}
			}
		}
	}
}

void conf_set_cvar(const string& name, const string& value)
{
	log("Set " + name + "=" + value);
	conf_cvars[name] = value;
}

string conf_get_cvar(const string& name)
{
	try
	{
		return conf_cvars.at(name);
	} catch (const out_of_range& err) {
		log("No cvar with name " + name + " defined. Returning \"\".", LP_ERROR);
		return "";
	}
}
